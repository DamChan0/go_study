# 함수 동작

## 단일 반환
1. C:= Add(a,b) 를 통하여 함수를 호출한다

2. 인수인 a,b 가 복사되어 func Add(a int, b int)로 전달된다

3. 함수 내부 로직이 동작하고 반환 되며 로컬 변수는 삭제된다

## Multi return 
1. 함수 선언시 반환할 타입에 2개 이상의 타입이 들어간다

2. 호출하고 반환 값을 받을 때 
``` go
	d, ok := MultiReturn(4, 2) // MultiReturn 함수를 호출한다.
```
와 같이 두개의 변수를 , 로 구분하여 선언하면서 대입하여 반환 값을 받을 수 있다.

3. MultiRetun2 함수를 보면 명시적으로 반환 값이 들어가는 변수 명을 지정할 수 있다.

4. 이경우 return 키워드 뒤에 반환할 값을 지정하지 않아도 함수 선언시 선언된 반환 변수가 반환된다

# 재귀 함수 (Recursive Functions)

재귀 함수는 자기 자신을 호출하는 함수입니다. 이는 큰 문제를 동일한 형태의 더 작은 문제로 나누어 해결하는 방식으로, 많은 알고리즘에서 사용됩니다.

## 재귀 함수의 구조

재귀 함수는 일반적으로 두 부분으로 구성됩니다:

1. **기본 케이스 (Base Case)**: 재귀 호출을 멈추는 조건입니다. 이를 "탈출 조건"이라고도 합니다.
2. **재귀 케이스 (Recursive Case)**: 함수가 자기 자신을 호출하는 부분입니다.

## 예시: 피보나치 수열

피보나치 수열은 재귀의 고전적인 예시입니다:

```go
func Fibo(n int) int {
    if n <= 1 {
        return n  // 기본 케이스
    }
    return Fibo(n-1) + Fibo(n-2)  // 재귀 케이스
}
```

- 기본 케이스: `n <= 1`일 때, 직접 값을 반환합니다.
- 재귀 케이스: `n > 1`일 때, `Fibo(n-1)`과 `Fibo(n-2)`를 호출하고 그 결과를 더합니다.

## 재귀 함수의 장단점

장점:
- 복잡한 문제를 간결하고 이해하기 쉬운 코드로 해결할 수 있습니다.
- 일부 알고리즘(예: 트리 순회, 퀵 정렬)은 재귀를 사용하면 매우 자연스럽게 구현됩니다.

단점:
- 깊은 재귀는 스택 오버플로우를 일으킬 수 있습니다.
- 때로는 반복문보다 성능이 떨어질 수 있습니다.
- 디버깅이 더 어려울 수 있습니다.

## 주의사항

1. 항상 기본 케이스(탈출 조건)를 명확히 정의해야 합니다.
2. 각 재귀 호출은 문제를 더 작은 문제로 줄여야 합니다.
3. 재귀 깊이가 너무 깊어지지 않도록 주의해야 합니다.
4. 성능이 중요한 경우, 동적 프로그래밍이나 반복문을 고려해 보세요.

## 재귀를 반복문으로 변환

대부분의 재귀 함수는 반복문으로 변환할 수 있습니다. 예를 들어, 위의 피보나치 함수는 다음과 같이 변환할 수 있습니다:

```go
func FiboIterative(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

이 버전은 재귀 버전보다 효율적이며 스택 오버플로우의 위험이 없습니다.

재귀는 강력한 도구이지만, 적절히 사용해야 합니다. 문제의 성격과 성능 요구사항을 고려하여 재귀 사용 여부를 결정하세요.